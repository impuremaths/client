<!DOCTYPE html><html lang="en">
<head>
	<meta charset="UTF-8">
	<title>mktplc</title>	
	<link rel="stylesheet" type="text/css" href="main.css">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@400;700&display=swap"> 
	
	<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
	<meta content="utf-8" http-equiv="encoding">
	<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
	<meta http-equiv="Pragma" content="no-cache">
	<meta http-equiv="Expires" content="0">
	
	<meta name="viewport" content="width=device-width, initial-scale=1.0">	
</head>

<body>
	<strong id="msg" class="msg" style="display:none;"></strong>
	
	<div class="containerDiv">
	
	<div id="firstDiv" class="firstDiv" style="background-color:steelblue">		
		<div id="profilePanel" class="objectWrapper" style="margin-bottom:15px; margin-top:50px" onclick="openSubAccordion(this)">
			<div class="clickFlash" style="display:flex; justify-content:space-between;" onclick="toggleSubAccordion(this)">
				<strong style="overflow:hidden"><div id="displayName" style="text-overflow:ellipsis; overflow:hidden; font-size:1.2em;" class="flash">Guest</div></strong>
			</div>

			<div id="editPanel" class="accordion" style="max-height:0px">
				<div style="text-align:center; margin-top:20px">
					<button tabindex="-1" class="left" onclick="generateSeed()">Create PIN</button><button id="current" class="center" tabindex="-1" onclick="showCurrent()" autocomplete="off" disabled>Current PIN</button><button id="clear" class="right" onclick="if (confirm('Log out of the current account? (Have you saved your account PIN elsewhere?!)')) clickClearSeed();" autocomplete="off" disabled>Log Out</button>
				</div>
				
				<div style="display:flex; justify-content:space-between; margin-top:15px; margin-bottom:20px">
					<input id="seed" placeholder="PIN (secret, save securely)..." style="padding-right:30px; flex-grow:1; flex-basis:20px;" type="password" autocomplete="off" onclick="this.select()" oninput="importSeed();">
					<button  tabindex="-1" class="close-icon" onclick="closeCopy(this.previousElementSibling)"></button>			
					<button id="show" tabindex="-1" style="font-size:0.85em; margin-left:10px" onclick="toggleVisibility()">Show</button>
				</div>
				
				<div id="grayout" style="opacity:0.3">
				<div style="font-size:0.9em">Public address:</div>
				<div class='address' style="margin-bottom:15px;" id="address" onclick="clickCopy(this, this.textContent)"> - </div>
			
				<div style="display:flex; justify-content:space-between;">
					<input placeHolder="Public display name..." id="set-name" autocomplete="off"
					       style="padding-right:30px; flex-grow:1;" type="text"autocapitalize="off" maxlength="64"
					       onkeyup="if (event.keyCode == 13) setData('name'); if (event.keyCode == 27) this.value = '';">
					<button  tabindex="-1" class="close-icon" onclick="closeCopy(this.previousElementSibling)"></button>
					<button style="font-size:0.85em; margin-left:10px" onclick="setData('name')" id="setDisplayBut" disabled>Set</button>
				</div>
				</div>
			</div>	
		</div>	
		
		<div id="subPanel" class="objectWrapper" style="overflow:hidden; display:none; flex-direction:column; flex-shrink:0; max-height:33vh" onclick="openSubAccordion(this)">
			<div class="clickFlash leftRightBase" style="margin-top:0px" onclick="toggleSubAccordion(this)">
				<strong>Subscriptions</strong>
			</div>
			<div class="accordion">
				<ul id="subscriptions" style="overflow:auto; max-height:calc(100% - 15px)"></ul>
			</div>
		</div>

		<div class="objectWrapper" style="margin-bottom:10px; overflow:hidden; display:flex; flex-direction:column" onclick="openSubAccordion(this)">
			<div class="clickFlash leftRightBase" style="margin-top:0px" onclick="toggleSubAccordion(this)">
				<strong>Library</strong>
			</div>
			<div class="accordion">
				<div id="libraryPlaceholder" style="font-style:italic; color:gray; text-align:center; margin-top:20px">Read something! (Log in to persist this list.)</div>
				<ul id="library" style="overflow:auto; max-height:calc(100% - 15px)"></ul>
			</div>
		</div>
		
	</div>
	
	
	<div id="secondDiv" class="secondDiv">
	
		<button id="browseButton" class="left active" style="margin-top:25px; margin-bottom:20px" onclick="loadPanel('browse')">Browse</button><button id="readButton" class="center" onclick="loadPanel('read')" autocomplete="off">Read</button><button id="postButton" class="right" onclick="loadPanel('post')" autocomplete="off">Write</button>
	
		<div id="browse" style="margin-bottom:80px">
			<div id="popularTags" style="margin-bottom:30px; margin-top:10px"></div>
			<div style="margin-top:20px; margin-bottom:20px">
			<span style="font-weight:bold; font-size:1.1em; cursor:pointer" onclick="queryBrowse()" id="info">Recent</span>
			<button id="subscribe" onclick="subscribeHandler()" autocomplete="off" style="display:none; padding:2px 8px; margin:2px; margin-left:5px" disabled>+</button>			
			<span id="loadingMsg" style="margin-left:10px; font-style:italic; display:none">Loading...</span>
			</div>
			<ul id="discovery"></ul>
		</div>

		<div id="post" style="display:none; margin-top:20px; margin-bottom:80px; max-width:1200px">
		
			<div style="flex-basis:1px; flex-grow:2; margin-right:50px; position:relative">
			
				<div style="display:flex; justify-content:center; position:absolute; right:0px; top:-10px;">
					<button id="editButton" class="left active" onclick="showEditor()">Editor</button><button id="previewButton" class="right" style="margin-left:5px" onclick="showPreview()">Preview</button>
				</div>
				
				<div id="postContent" style="margin-bottom:40px; margin-top:40px"></div>
				<div id="postPreview" style="white-space:pre-wrap; margin-bottom:40px; margin-top:40px; display:none">Hi</div>
				
			</div>
			
			<div style="flex-basis:1px; flex-grow:1; max-width:360px; margin-right:20px">
				<input id="postTitle" style="font-weight:bold; font-size:1.1em; width:100%; margin-bottom:10px;" autocomplete="off" placeholder="Title (required)..." type="text" onkeyup="if (event.keyCode == 27) this.value = '';">
				<div id="editid" style="font-size:0.85em; margin-left:10px; display:none">
				<span id="creationEdit"></span><span id="modificationEdit"></span>
				</div>
				
				<div style="display:flex; margin-left:20px; margin-top:15px">
					<input id="set-tag" style="padding-right:30px; flex-grow:1; margin-right:10px" autocomplete="off" placeHolder="tag (lowercase only)..." type="text" onkeyup="if (event.keyCode == 27) this.value = ''; if (event.keyCode == 13) addTag()" autocapitalize="off">
					<button tabindex="-1" style="font-size:0.85em; min-width:fit-content" onclick="addTag()">Add</button>
				</div>
				<div id="editTags" style="font-size:0.85em; margin-left:20px; margin-top:10px"></div>
						
						
				<div style="margin-top:40px; display:flex; justify-content:space-between; flex-grow:1">
					<input placeHolder="Previous post link..." id="set-prev" autocomplete="off"
						   style="padding-right:30px; flex-grow:1; width:1px" type="text" autocapitalize="off" onkeyup="if (event.keyCode == 27) this.value = ''; checkTitle(this);" oninput="checkTitle(this);">
					<button tabindex="-1" class="close-icon" onclick="closeCopy(this.previousElementSibling)"></button>
				</div>
				
				<div style="display:flex; margin-top:10px; justify-content:space-between;">
					<span style="text-overflow:ellipsis; overflow:hidden; white-space:nowrap">(none)</span>
					<button onclick="toggle(this)" tabindex="-1" style="font-size:0.85em; min-width:fit-content" disabled>Reciprocate Link</button>
				</div>
				
				<div style="margin-top:15px; display:flex; justify-content:space-between; flex-grow:1">
					<input placeHolder="Next post link..." id="set-next" autocomplete="off"
						   style="padding-right:30px; flex-grow:1; width:1px" type="text" autocapitalize="off" onkeyup="if (event.keyCode == 27) this.value = ''; checkTitle(this);"oninput="checkTitle(this);">
					<button tabindex="-1" class="close-icon" onclick="closeCopy(this.previousElementSibling)"></button>
				</div>
				
				<div style="display:flex; margin-top:10px; justify-content:space-between;">
					<span style="text-overflow:ellipsis; overflow:hidden; white-space:nowrap">(none)</span>
					<button onclick="toggle(this)" tabindex="-1" style="font-size:0.85em; min-width:fit-content" disabled>Reciprocate Link</button>
				</div>
					
				
				<div style="margin-top:50px; display:flex;">
					<button id="submitButton" onclick="post()" tabindex="-1" disabled>Publish</button>
					<button id="clearButton" style="margin-left:5px" tabindex="-1" onclick="if (confirm('Clear current draft?')) cancelPost()">Clear</button>	
				</div>
			</div>
		</div>
		
		<div id="read" style="display:none; margin-top:20px; margin-bottom:80px">
			<div style="flex-basis:1px; flex-grow:2; margin-right:50px;">
				
				<div id="readContent" style="white-space:pre-wrap; margin-bottom:40px; margin-top:40px">Browse for something interesting. Content displays here.</div>
				
				<div style="background-color:#e4e7e7; height:2px; border-radius:20px; margin:30px;"></div>
				
				<textarea id="commentContent" style="margin-top:10px; margin-bottom:10px; height:80px; width:100%; display:none" autocomplete="off" onkeyup="commentKeypress()" oninput="commentKeypress()" placeholder="Comment..."></textarea>
				<div style="display:flex; justify-content:right; margin-right:10px">
				<button id="comment" style="margin-top:5px; font-size:0.85em" onclick="comment()" disabled>Comment</button>
				</div>
				<ul id="readComments" style="white-space:pre-wrap;"><ul>
			</div>
			
	
			<div style="flex-basis:1px; flex-grow:1; max-width:360px">
			
				<div id="readTitle" style="font-weight:bold; font-size:1.1em; margin-bottom:3px;">Title</div>	
				
				<div style="font-size:0.85em">
					<div id="tags">
						<a id="author" onclick="queryBrowse(this.title)" style="cursor:pointer; font-weight:600">Author</a>
						<a onclick="queryBrowse(this.title)" style="cursor:pointer"> • tag</a>
					</div>
				
					<div style="margin-top:3px">
						<span id="creation">Date published</span><span id="modification"> - modified</span>
						<a id="edit" onclick="event.preventDefault(); fillEdit(); queryPost();" style="cursor:pointer; display:none"> • Edit</a>
					</div>
				</div>
				
				<ul id="mapul"></ul>
			</div>
		</div>
		
	</div>
	
	</div>
	
<script src="nacl.js"></script>
<script src="xno.js"></script>
<script src="tweetnacl.js"></script>
<script src="dompurify.js"></script>
  <script src="marked.js"></script>
<script>

// crypto methods ///////////////////////////////////////////////////////////////////////

var XNO = {};

XNO.checkSeed = function(seed) { return typeof seed === "string" && /^[0-9a-fA-F]{64}$/.test(seed);};

XNO.checkAddress = function(address) { 
	if (!(typeof address === "string") || !/^(nano_)[13][13-9a-km-uw-z]{59}$/.test(address)) return false;
	const checksumBytes = decodeNanoBase32(address.substr(5 + 52));
	const computedChecksumBytes = blake2b(decodeNanoBase32(address.substr(5, 52)), null, 5).reverse();
	for (let i = 0; i < checksumBytes.length; i++) {
		if (checksumBytes[i] !== computedChecksumBytes[i]) return false;
	}
	return true;
};

XNO.generateSeed = function() {
	const seed = new Uint8Array(32);
	crypto.getRandomValues(seed);
	return Array.prototype.map.call(seed, (x) => ('00' + x.toString(16)).slice(-2)).join('').toUpperCase();
};


XNO.derivePrivateKey = function(seed, index) {
  const indexBuffer = new ArrayBuffer(4)
  const indexView = new DataView(indexBuffer)
  indexView.setUint32(0, index)
  const indexBytes = new Uint8Array(indexBuffer)

  const context = blake2bInit(32)
  blake2bUpdate(context, hexToByteArray(seed))
  blake2bUpdate(context, indexBytes)
  return byteArrayToHex(blake2bFinal(context))
}

XNO.addressFromSeed = function(seed) { return XNO.addrFromPub(XNO.pubFromPriv(XNO.derivePrivateKey(seed, 0))); }
XNO.pubFromPriv = function(privateKey) { return byteArrayToHex(derivePublicFromSecret(hexToByteArray(privateKey))); };
XNO.addrFromPub = function(publicKey) { return 'nano_' + encodeNanoBase32(hexToByteArray(publicKey)) + encodeNanoBase32(blake2b(hexToByteArray(publicKey), null, 5).reverse()); }
XNO.pubFromAddr = function(address) { return byteArrayToHex(decodeNanoBase32(address.substr(5, 52))); };

XNO.sign = function(message) { return byteArrayToHex(signDetached(enc.encode(message), hexToByteArray(XNO.privateKey))); }
XNO.verify = function(message, signature, address) {
	try { return verifyDetached(enc.encode(message), hexToByteArray(signature), hexToByteArray(XNO.pubFromAddr(address))); }
	catch { return false };
}

XNO.unpackSeed = function(seed, index) {
	XNO.seed = seed;
	XNO.privateKey = XNO.derivePrivateKey(seed, index);
	XNO.publicKey = XNO.pubFromPriv(XNO.privateKey);
	XNO.address = XNO.addrFromPub(XNO.publicKey);
	XNO.encryptKey = nacl.box.keyPair.fromSecretKey(hexToByteArray(XNO.privateKey));
}

function byteArrayToHex(byteArray) {
  if (!byteArray) return '';
  let hexStr = '';
  for (let i = 0; i < byteArray.length; i++) {
    let hex = (byteArray[i] & 0xff).toString(16)
    hex = hex.length === 1 ? `0${hex}` : hex;
    hexStr += hex;
  }
  return hexStr.toUpperCase()
}

function hexToByteArray(hex) {
  if (!hex) return new Uint8Array();
  const a = [];
  for (let i = 0; i < hex.length; i += 2) {
    a.push(parseInt(hex.substr(i, 2), 16));
  }
  return new Uint8Array(a);
}

// Global variables and macros; and initializers ///////////////////////////////////////////////////////////////////////

var readPostid = "";
var editPostid = "";
var topPage = "browse";
var DOMdisplayNames = {};
var cacheDisplayNames = {};
var postCache = {};
const enc = new TextEncoder();
const dec = new TextDecoder();
function D(string) { return document.getElementById(string); }

let browseHeight = 0;
let readHeight = 0;
let postHeight = 0;

const adj = ["Disillusioned", "Nihilistic", "Disenchanted", "Embittered", "Worldly", "Embattled", "Cynical", "Skeptical", "Contemplative", 
				"Introspective", "Meditative", "Pensive", "Philosophical", "Stoic", "Apathetic", "Analytical", "Scholarly", "Erudite", "Composed", "Detached"];
const animals = ["Puppy", "Kitten", "Bunny", "Hamster", "Panda", "Otter", "Hedgehog", "Penguin", "Squirrel", "Turtle", "Koala", "Hatchling", "Kit", "Joey", "Fledgling", 
					"Fawn", "Foal", "Calf", "Cub", "Colt", "Piglet", "Eaglet", "Owlet"];

var serverURL = 'wss://impuremaths.herokuapp.com';
var ws = new WebSocket(serverURL);
setupWebsocket();

let localSeed = localStorage.getItem("localSeed");
if (localSeed) {
	D("seed").value = localSeed;
	importSeed();
}

cancelPost();
if (new URLSearchParams(window.location.search).get('postid')) loadPanel('read');


// Websocket code ///////////////////////////////////////////////////////////////////////

function setupWebsocket(restart) {
	ws.customEvents = {};
	ws.on = function(cueName, eventAction) { ws.customEvents[cueName] = eventAction; };
	ws.emit = function(cueName, payload) { 
		if (ws.readyState == 1) ws.send(JSON.stringify({cueName:cueName, payload:payload})); 
		return (ws.readyState == 1);
	};
	
	// Standard commands
	ws.onopen = function() { 
		console.log("Connected to server!"); 
		if (!restart) {		
			ws.emit('queryTagCounts');
			if (new URLSearchParams(window.location.search).get('postid')) ws.emit('queryPostsRecent');
			loadURL();					
		}
		if (XNO.address) {
			let ts = Date.now();
			let loginPacket = {userid: XNO.address, ts, signature:XNO.sign(ts, XNO.address)};
			ws.emit('authenticateUser', loginPacket);
			console.log(loginPacket);
		}
	};
	ws.onclose = function() { 
		ws = new WebSocket(serverURL);
		setupWebsocket(true);
	}
	ws.onmessage = function(event) {
		let data;
		try { data = JSON.parse(event.data); }
		catch { 
			console.log("Unparseable server message.")
			console.error(event.data);
			return false;
		}			
		if (data && data.cueName && ws.customEvents[data.cueName]) ws.customEvents[data.cueName](data.payload);
		else {
			console.error("Unrecognized server message.")
			console.error(event.data);
		}
	};

	// Custom commands ////////////////////////////////////////////////////////
	
	ws.on('serverPongCue', function(data) { 
		console.log(data);
		console.log(new Date(data));
	});
	
	ws.on('updateDisplayNameResponse', function(data) {
		if (data && data.displayname) {
			D('displayName').textContent = data.displayname;
			receiveDOMdisplayName(data.userid, data.displayname);
		}
	});
	
	ws.on('authenticateUserResponse', function(data) {
		clearDOM(D('subscriptions'));
		if (XNO.address) makeSubLi(XNO.address);
		if (data.edges) {
			for (let i = 0; i < data.edges.length; i++) {
				makeSubLi(data.edges[i].userid, data.edges[i].lastaccessedts, data.edges[i].lastpublishedts);
			}
			requestNames();
		}
		
		if (data && data.displayname) {
			D('displayName').textContent = data.displayname;			
			receiveDOMdisplayName(data.userid, data.displayname);
		}
		console.log("Authenticated! Requesting library...");
		ws.emit('queryLibrary');
	});
	
	ws.on('queryLibraryResponse', function(data) {
		clearDOM(D('library'));
		data.sort(function(x, y) { return Math.round(x.pushedts - y.pushedts); });
		console.log(data);
		for (let i = 0; i < data.length; i++) {
			cachePost(data[i]);
			makeLibLi(data[i].postid, data[i].lastaccessedts);
		}
		requestNames();
	});
	
	function receiveDOMdisplayName(userid, displayname) {
		if (displayname) cacheDisplayNames[userid] = displayname;
		else delete cacheDisplayNames[userid];
		if (DOMdisplayNames[userid]) {
			for (let j = 0; j < DOMdisplayNames[userid].length; j++) {
			DOMdisplayNames[userid][j].textContent = funName(userid);
			}
		}
		delete DOMdisplayNames[userid];
	}
	
	ws.on('queryUsersResponse', function(data) { 
		for (let i = 0; i < data.length; i++) {
			receiveDOMdisplayName(data[i].userid, data[i].displayname);
		}
	});
	
	ws.on('queryPostsRecentResponse', function(data) { 
		D('subscribe').style.display = "none";
		D('info').textContent = "Recent";
		D('info').title = "";
		fillBrowse(data); 
	});
	
	ws.on('queryPostsFromUser', function (data) { 
		fillBrowse(data);
		if (data.length && D(postCache[data[0].postid].userid)) D(postCache[data[0].postid].userid).style.fontWeight = "";
	});
	
	
	ws.on('queryTagResponse', function (data) { fillBrowse(data); });
	
	ws.on('queryPostResponse', function(data) { 
		console.log(data);
		let oldPost = readPostid && (JSON.stringify(data.content) == JSON.stringify(postCache[readPostid].content));
		cachePost(data);
		if (editPostid == data.postid) {
			fillEdit(data.postid); 
			editPostid = "";
		} else fillPost(data.postid, oldPost);
	});
	
	ws.on('updatePostResponse', function(data) { 
		console.log(data);
		cachePost(data);
		if (!data.errMsg) {
			fillPost(data.postid);
			loadPanel('read');
			cancelPost();
		} else console.log(data);
	});
	
	ws.on('subscribeResponse', function(data) {	console.log(data); });
	
	ws.on('sponsorResponse', function(data) { 
		console.log(data);
		makeSubLi(data.userid2); 
	});
	
	ws.on('updateCommentResponse', function(data) {	addComment(data); });
	
	ws.on('queryPostChainResponse', function(data) { 
		clearDOM(D('mapul'));
		for (let x in data) {	
			cachePost(data[x]);		
			let postli = make('li');
			postli.style = "white-space:nowrap";
			if (readPostid == data[x].postid) activeBar(postli);
			postli.appendChild(fullLabel(data[x].postid));
			D('mapul').appendChild(postli);	
		}
	});
	
	ws.on('queryTagCountsResponse', function(data) {
		console.log(data);
		clearDOM(D('popularTags'));

		let tagElt = make('span', 'Recent');
		tagElt.style = "margin-right:20px; font-size:0.85em; cursor:pointer; display:inline-block; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:250px";
		tagElt.onclick = function() {
			queryBrowse(null, null);
		};
		D('popularTags').appendChild(tagElt);
		
		for (let tag in data) {
			if (data[tag] > 0) {
				let tagElt = make('span', tag);
				tagElt.style = "margin-right:20px; font-size:0.85em; cursor:pointer; display:inline-block; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:250px";
				tagElt.onclick = function() {
					queryBrowse(null, tag);
				};
				D('popularTags').appendChild(tagElt);
			}
		}
	});
}


// Main panel UI interaction handlers ///////////////////////////////////////////////////////////////////////

function queryBrowse(userid, tag) {
	let urltag = new URLSearchParams(window.location.search).get('tag');
	let urluserid = new URLSearchParams(window.location.search).get('userid');
	let url = new URL(window.location);
	if (userid) {	
		if (urluserid != userid) {		
			url.search = new URLSearchParams({userid});
			window.history.pushState(null, "", url);
		}
		document.title = funName(userid) + " - mktplc";
	} else if (tag) {
		if (urltag != tag) {
			url.search = new URLSearchParams({tag});
			window.history.pushState(null, "", url);	
		}
		document.title = tag + " - mktplc";
	} else {
		if (urltag || urluserid || (new URLSearchParams(window.location.search).get('postid'))) {
			url.search = new URLSearchParams();
			window.history.pushState(null, "", url);
		}
		document.title = "mktplc";
	}
	
	if (userid) {		
		if (userid == XNO.address) D('subscribe').style.display = "none";
		else D('subscribe').style.display = "";		
		D('info').title = userid;
		D('info').textContent = funName(userid);
		queueDOMdisplayName(userid, D('info'));
		if (ws && ws.readyState == 1) {
			D('loadingMsg').style.display = "";
			ws.emit("queryPostsFromUser", {userid});
		}
	} else if (tag) {	
		D('subscribe').style.display = "";		
		D('info').title = tag;
		D('info').textContent = tag;
		if (ws && ws.readyState == 1) {
			D('loadingMsg').style.display = "";
			ws.emit("queryTag", {tag});
		}
	} else {	
		D('subscribe').style.display = "none";
		D('info').title = "";
		D('info').textContent = "Recent";
		if (ws && ws.readyState == 1) {
			D('loadingMsg').style.display = "";
			ws.emit('queryPostsRecent');
			ws.emit('queryTagCounts');
		}
	}
	D('info').onclick = function() { queryBrowse(userid, tag); };
	loadPanel('browse');
}

function subscribeHandler() {
	if (D(D('info').title)) flash(D(D('info').title));
	else {
		makeSubLi(D('info').title);
		if (ws && ws.readyState == 1) ws.emit("subscribe", {userid: D('info').title});
	}
}

function addTag() {
	let newTagFlag = D('set-tag').value.toLowerCase().trim();
	for (let i = 0; i < D('editTags').children.length; i++) {
		if (D('editTags').children[i].textContent == newTagFlag) {
			newTagFlag = "";
			flash(D('editTags').children[i]);
		}
		if (!newTagFlag) break;
	}
	
	if (newTagFlag) {
		let newTag = make('span', newTagFlag);
		newTag.onclick = function() { this.parentNode.removeChild(this); }
		newTag.style = "cursor:pointer; margin:5px 10px 0px 10px; padding:3px 5px 3px 5px; border-radius:5px; display:inline-block";
		D('editTags').appendChild(newTag);
		flash(newTag);
	}
	D('set-tag').value = "";
	D('set-tag').select();
}

function post() {
	if (!D('postTitle').value.trim()) {
		alert("Title is required.");
		return false;
	}
	let prev = "";
	try { prev = new URLSearchParams((new URL(D('set-prev').value)).search).get('postid');} 
	catch { prev = "" };
	let next = "";	
	try { next = new URLSearchParams((new URL(D('set-next').value)).search).get('postid');} 
	catch { next = "" };
	
	let content = [];
	for (let i = 0; i < D('postContent').children.length; i++) {
		if (D('postContent').children[i].firstChild.title == "image")
			content.push({content:D('postContent').children[i].firstChild.firstChild.value, type:D('postContent').children[i].firstChild.title});
		else if (D('postContent').children[i].firstChild.value)
			content.push({content:D('postContent').children[i].firstChild.value, type:D('postContent').children[i].firstChild.title});
	}
	
	let tags = [];
	for (let i = 0; i < D('editTags').children.length; i++) {	
		tags.push(D('editTags').children[i].textContent);
	}

	ws.emit('updatePost', {tags, prev_: prev, next_: next, title:D('postTitle').value.trim(), content:content, visibility:"public", createdts: parseInt(D('creationEdit').title)});
}

function checkTitle(elt) {
	let prev = "";
	try { prev = new URLSearchParams((new URL(elt.value)).search).get('postid');} 
	catch { prev = "" };
	
	if (prev) {
		if (postCache[prev]) elt.parentNode.nextElementSibling.firstElementChild.textContent = postCache[prev].title;
		else elt.parentNode.nextElementSibling.firstElementChild.textContent = "(unknown post)";
		
		let split = prev.split("-");
		let userid = split[0];		
		if (userid == XNO.address) {
			elt.parentNode.nextElementSibling.children[1].classList.add('active');
			elt.parentNode.nextElementSibling.children[1].disabled = false;
		} else {
			elt.parentNode.nextElementSibling.children[1].classList.remove('active');
			elt.parentNode.nextElementSibling.children[1].disabled = true;		
		}		
	} else {
		elt.parentNode.nextElementSibling.firstElementChild.textContent = "(none)"; 
		elt.parentNode.nextElementSibling.children[1].classList.remove('active');
		elt.parentNode.nextElementSibling.children[1].disabled = true;
	}
}

function commentKeypress() {
	if (event.keyCode == 27) {
		D('commentContent').value = "";
		D('commentContent').style.display = "none";
		D("comment").textContent = "Comment";
		event.stopPropagation();
	} else if (D('commentContent').value) D("comment").textContent = "Comment";
	else D("comment").textContent = "Cancel";
}

function comment() {
	if (D('commentContent').style.display) {
		D('commentContent').style.display = "";
		D("comment").textContent = "Cancel";
		D('commentContent').focus();
	} else {
		D('commentContent').style.display = "none";
		D("comment").textContent = "Comment";
		ws.emit('updateComment', {content:D('commentContent').value, postid: D('author').title + "-" + D('creation').title});
		D('commentContent').value = "";
	}
}

function showEditor() {
	clearDOM(D('postPreview'));
	D('editButton').classList.add('active');
	D('previewButton').classList.remove('active');
	D('postContent').style.display = "";
	D('postPreview').style.display = "none";
}

function showPreview(elt) {
	let content = [];
	for (let i = 0; i < D('postContent').children.length; i++) {
		if (D('postContent').children[i].firstChild.title == "image")
			content.push({content:D('postContent').children[i].firstChild.firstChild.value, type:D('postContent').children[i].firstChild.title});
		else if (D('postContent').children[i].firstChild.value)
			content.push({content:D('postContent').children[i].firstChild.value, type:D('postContent').children[i].firstChild.title});
	}
	fillContent(D('postPreview'), content);
	
	D('previewButton').classList.add('active');
	D('editButton').classList.remove('active');
	D('postContent').style.display = "none";
	D('postPreview').style.display = "";
}

function loadPanel(type) {	
	if (D('browse').style.display != 'none') browseHeight = Math.ceil(D('secondDiv').scrollTop);
	if (D('read').style.display != 'none') readHeight = Math.ceil(D('secondDiv').scrollTop);
	if (D('post').style.display != 'none') postHeight = Math.ceil(D('secondDiv').scrollTop);
	
	D('post').style.display = 'none';
	D('read').style.display = 'none';
	D('browse').style.display = 'none';
	
	D('postButton').classList.remove('active');
	D('readButton').classList.remove('active');
	D('browseButton').classList.remove('active');
	
	D(type).style.display = "";
	D(type + "Button").classList.add('active');
	
	if (type == "read") {
		D(type).style.display = "flex";
		D('secondDiv').scrollTo(0, readHeight);
	}
	if (type == "post") {
		D(type).style.display = "flex";
		D('secondDiv').scrollTo(0, postHeight);		
	}
	if (type == "browse") D('secondDiv').scrollTo(0, browseHeight);
	
	if (type != "post") topPage = type;
}

function cachePost(metaData) {
	if (!metaData.postid) metaData.postid = metaData.userid + "-" + metaData.createdts.toString();	
	if (!metaData.userid) {
		let split = metaData.postid.split("-");
		metaData.userid = split[0];
		metaData.createdts = parseInt(split[1]);
	}
	
	if (!postCache[metaData.postid]) postCache[metaData.postid] = {};

	postCache[metaData.postid].title = metaData.title;
	postCache[metaData.postid].userid = metaData.userid;
	postCache[metaData.postid].createdts = metaData.createdts;
	postCache[metaData.postid].postid = metaData.postid;

	if (metaData.modifiedts) postCache[metaData.postid].modifiedts = metaData.modifiedts;
	if (metaData.content) postCache[metaData.postid].content = metaData.content;
	if (metaData.tags) postCache[metaData.postid].tags = metaData.tags;
	if (metaData.comments) postCache[metaData.postid].comments = metaData.comments;
	if (metaData.prev_) postCache[metaData.postid].prev_ = metaData.prev_;
	if (metaData.next_) postCache[metaData.postid].next_ = metaData.next_;
}

function activeBar(elt) {
	elt.style.borderLeft = "solid 4px #aaa";		
	elt.style.paddingLeft = "5px";
}

function removeActiveBar(elt) {
	elt.style.borderLeft = "";	
	elt.style.paddingLeft = "";
}

function fillBrowse(data) {	
	data.sort(function(x, y) { return y.createdts - x.createdts; });
	D('loadingMsg').style.display = "none";
	clearDOM(D('discovery'));
	
	for (let i = 0; i < data.length; i++) {	
		cachePost(data[i]);			
		let postli = make('li');
		postli.id = data[i].postid + "-disc";
		postli.style = "width:max-content; display:flex; align-items:center; min-width:550px";
		if (readPostid == data[i].postid) activeBar(postli);
		postli.appendChild(fullLabel(data[i].postid));
		D('discovery').appendChild(postli);
	}
	
	requestNames();
}

function fullLabel(postid, library) {
	let data = postCache[postid];
	let postTitle = make('div', data.title);
	postTitle.title = data.title;
	postTitle.style = "overflow:hidden; text-overflow:ellipsis";
	
	// author and tags
	let tags = make('div');
	tags.style = "font-size:0.85em; overflow: hidden; text-overflow:ellipsis;";
	
	let postAuthor = make('a', funName(data.userid));
	postAuthor.title = data.userid;
	postAuthor.style = "cursor:pointer; font-weight:600";
	postAuthor.style.color = funColor(data.userid);
	postAuthor.onclick = function() {
		event.stopPropagation();
		queryBrowse(data.userid);
	};	
	queueDOMdisplayName(data.userid, postAuthor);
	tags.appendChild(postAuthor);
	
	if (data.tags) {
		for (let i = 0; i < data.tags.length; i++) {
			let tag = make('a', " • " + data.tags[i]);
			tags.appendChild(tag);
			tag.onclick = function() {
				event.stopPropagation();
				queryBrowse(null, data.tags[i]);
			};
		}
	}
	
	// Meta: dates, edit
	let postMeta = make('div');
	postMeta.style = "font-size:0.85em; overflow:hidden; text-overflow:ellipsis";	
	
	let postDate = make('span', timeSince(data.createdts));	
	postDate.title = data.createdts;
	postMeta.appendChild(postDate);	
	
	if (data.modifiedts && data.modifiedts != data.createdts) {
		let postModified = make('span', " - " + timeSince(data.modifiedts));
		postModified.title = data.modifiedts;
		postMeta.appendChild(postModified);
	}	
		
	if (data.userid == XNO.address) {
		let editBut = make('a', " • Edit");			
		editBut.onclick = function() {
			event.stopPropagation();
			fillEdit(postid);
			queryPost(postid);
		}
		postMeta.appendChild(editBut);		
	}
	
	// Hover buttons
	let actions = make('div');
	actions.style = "position:absolute; top:0px; right:0px; display:none; opacity:0.8";
	
	let postLink = make('button', "Link");
	postLink.classList.add("left");
	postLink.style.marginRight = "4px";
	postLink.onclick = function() {
		event.stopPropagation();
		let url = new URL(window.location);
		url.search = new URLSearchParams({postid});
		clickCopy(this, url.href);
	};
	actions.appendChild(postLink);
	
	let addBut = make('button', "＋");
	addBut.classList.add("right");
	actions.appendChild(addBut);
	if (library) {
		addBut.textContent = "✕";
		addBut.onclick = function() {
			event.stopPropagation();
			label.parentNode.parentNode.removeChild(label.parentNode);
			if (ws && ws.readyState == 1) ws.emit('deleteLibrary', {postid:label.parentNode.id});
			if (!D('library').children[0]) D('libraryPlaceholder').style.display = "";
		};	
	} else addBut.onclick = function() {
		event.stopPropagation();
		if (!D(postid)) addToLib(postid, true);
		flash(D(postid));
	}
	
	let label = make('div');
	label.appendChild(postTitle);
	label.appendChild(tags);
	label.appendChild(postMeta);
	label.appendChild(actions);
	
	label.style = "overflow:hidden; cursor:pointer; padding:5px; flex-grow:1; position:relative";
	label.onmouseenter = function() { actions.style.display = ""; };
	label.onmouseleave = function() { actions.style.display = "none"; };
	label.onclick = function() {
		fillPost(postid);
		loadPanel('read');
		queryPost(postid);
		if (!D(postid)) addToLib(postid);
		else D(postid).style.fontWeight = "";
		flash(this);
	}
	return label;
}

function fillPost(postid, oldPost) {
	if (new URLSearchParams(window.location.search).get('postid') != postid) {		
		let url = new URL(window.location);
		url.search = new URLSearchParams({postid});
		window.history.pushState(null, "", url);
	}
	document.title = postCache[postid].title + " - mktplc";
	
	D('commentContent').style.display = 'none';
	D('commentContent').value = "";
	D('comment').textContent = "Comment";
	
	// handle left bars
	if (readPostid && D(readPostid)) removeActiveBar(D(readPostid));
	if (readPostid && D(readPostid + "-disc")) removeActiveBar(D(readPostid + "-disc"));
	readPostid = postid;
	if (D(postid)) activeBar(D(postid));
	if (D(postid + "-disc")) activeBar(D(postid + "-disc"));
	
	let metaData = postCache[postid];
	queueDOMdisplayName(metaData.userid, D('author'));
	
	// Title and label
	D('readTitle').textContent = metaData.title;
	D('author').textContent = funName(metaData.userid);
	D('author').style.color = funColor(metaData.userid);
	D('author').title = metaData.userid;
	
	while (D('tags').children.length > 1) D('tags').removeChild(D('tags').lastElementChild);
	if (metaData.tags) {
		for (let i = 0; i < metaData.tags.length; i++) {
			let tag = make('a', " • " + metaData.tags[i]);
			tag.style = "cursor:pointer";
			D('tags').appendChild(tag);
			tag.onclick = function() {
				event.stopPropagation();
				queryBrowse(null, metaData.tags[i]);
			};
		}
	}
	
	D('creation').textContent = new Date(metaData.createdts).toLocaleDateString();
	D('creation').title = metaData.createdts;
	if (metaData.modifiedts && metaData.modifiedts != metaData.createdts) {
		D('modification').textContent = " - " + new Date(metaData.modifiedts).toLocaleDateString();
		D('modification').title = metaData.modifiedts;
		D('modification').style.display = "";
	} else {
		D('modification').textContent = "";
		D('modification').title = "";
		D('modification').style.display = "none";
	}	
	if (metaData.userid == XNO.address) D('edit').style.display = "";
	else D('edit').style.display = "none";
	
	// content
	if (metaData.content) {
		if (!oldPost) {
			if (typeof metaData.content === "string") D('readContent').textContent = metaData.content;
			else fillContent(D('readContent'), metaData.content);
		}
	} else D('readContent').innerHTML = "<i>Loading...</i>";
	
	// comments
	if (XNO.address) D("comment").disabled = false;
	clearDOM(D('readComments'));	
	if (metaData.comments) {
		metaData.comments.sort(function(x, y) {
			return parseInt(x.commentid.split("-")[1]) - parseInt(y.commentid.split("-")[1]);
		});		
		for (let i = 0; i < metaData.comments.length; i++) {
			addComment(metaData.comments[i]);
		}	
	}
	ws.emit("queryPostChain", {userid:metaData.userid, createdts:metaData.createdts });
}

function fillContent(elt, content) {
	clearDOM(elt);
	for (let i = 0; i < content.length; i++) {
		if (content[i].type == "js") {
			let jsbox = make("iframe");
			jsbox.style = "width:100%; height:0px; border-top:0px; border-bottom:0px; border-left:4px solid white; border-right:0px; border-radius:4px 0px 0px 4px";
			jsbox.onmouseenter = function() {
				jsbox.style.borderColor = "#aaa";
			}
			jsbox.onmouseleave = function() {
				jsbox.style.borderColor = "transparent";
			}
			jsbox.sandbox = "allow-scripts";
			let str = `<script>window.onload = function() {
				window.parent.postMessage({height:Math.max( document.body.scrollHeight, document.body.offsetHeight, document.body.clientHeight,
				document.body.parentElement.scrollHeight, document.body.parentElement.offsetHeight, document.body.parentElement.clientHeight)}, '*');
			};<` + "/" + `script>`;
			jsbox.srcdoc = content[i].content + str;
			jsbox.style.marginBottom = "20px";
			elt.appendChild(jsbox);
		} else if (content[i].type == "md") {				
			let mdbox = make("div");
			mdbox.innerHTML = DOMPurify.sanitize(marked.parse(content[i].content));
			mdbox.style.marginBottom = "20px";
			mdbox.style.whiteSpace = "initial";
			elt.appendChild(mdbox);				
		} else if (content[i].type == "image") {
			let imagediv = make("img");	
			imagediv.src = content[i].content;
			imagediv.alt = "[Broken image link]";
			imagediv.style.maxWidth = "100%";
			let imageHolder = make('div');
			imageHolder.style = "display:flex; justify-content:center; margin-bottom:20px";
			imageHolder.appendChild(imagediv);
			elt.appendChild(imageHolder);
		} else {
			let textbox = make("div", content[i].content);
			textbox.style.marginBottom = "20px";
			elt.appendChild(textbox);
		}
	}
}

function fillEdit(postid) {
	if (!postid) postid = readPostid;
	editPostid = postid;
	let metaData = postCache[postid];
	D('editid').style.display = "";
	D('creationEdit').textContent = new Date(metaData.createdts).toLocaleDateString();
	D('creationEdit').title = metaData.createdts;
	if (metaData.modifiedts && metaData.createdts != metaData.modifiedts) {
		D('modificationEdit').textContent = " - " + new Date(metaData.modifiedts).toLocaleDateString();
		D('modificationEdit').title = metaData.modifiedts;
	}	
	
	clearDOM(D('postContent'));
	if (typeof metaData.content === "string") {	
		let block = appendBlock();
		block.firstChild.value = metaData.content;
	} else if (metaData.content) {
		for (let i = 0; i < metaData.content.length; i++) {
			let block = appendBlock(metaData.content[i].type);
			if (metaData.content[i].type == "image") block.firstChild.firstChild.value = metaData.content[i].content;
			else block.firstChild.value = metaData.content[i].content;
		}
	} 
	D('postTitle').value = metaData.title;
	
	let url = new URL(window.location);
	url.search = new URLSearchParams({postid: metaData.prev_});
	if (metaData.prev_) D('set-prev').value = url.href;
	url.search = new URLSearchParams({postid: metaData.next_});	
	if (metaData.next_) D('set-next').value = url.href;
	
	clearDOM(D('editTags'));
	if (metaData.tags) {
		for (let i = 0; i < metaData.tags.length; i++) {
			D('set-tag').value = metaData.tags[i];
			addTag();
		}
	}
	
	D('submitButton').textContent = "Publish Edit";
	D('clearButton').textContent = "Cancel Edit";
	loadPanel('post');
}

function appendBlock(type, parent) {
	let block = make('div');
	block.tabIndex = "-1";
	let textbox = make('textarea');
	textbox.style = "height:150px; width:100%";
	
	if (!type) type = "text";
	if (type == "text") {
		textbox.style.fontFamily = "Segoe UI, Source Sans Pro, Roboto, Helvetica, sans-serif";
		textbox.placeholder = "Simple text...";
	} else if (type == "js") {
		textbox.placeholder = "HTML (JS scripts enabled)...";
		textbox.onkeydown = function() {
			if (event.keyCode == 9) {
				event.preventDefault();
				console.log("HANDLE TABS");
			}
		}
		addTabbing(textbox);
	} else if (type == "md") textbox.placeholder = "Markdown...";
	else if (type == "image") {
		textbox = make('div');		
		textbox.style = "display:flex; margin-top:20px;";
		textbox.innerHTML = `<input placeHolder="Image URL..." autocomplete="off" style="padding-right:30px; flex-grow:1; width:1px" type="text" autocapitalize="off" onkeyup="if (event.keyCode == 27) this.value = '';"><button  tabindex="-1" class="close-icon" onclick="closeCopy(this.previousElementSibling)">`;
		textbox.innerHTML += "</button>";
	}
	textbox.title = type;
	block.appendChild(textbox);	
	
	let sponsBut = make('button', "Sponsors Only");
	sponsBut.style.marginRight = "5px";
	sponsBut.style.fontSize = "0.85em";
	sponsBut.tabIndex = "-1";
	sponsBut.onclick = function() { toggle(this); }
	
	let textBut = make('button', "Add Text");
	textBut.classList.add("left");
	textBut.onclick = function() { appendBlock("text", block); }
	
	let mdBut = make('button', "Markdown");
	mdBut.classList.add("center");
	mdBut.style.marginRight = "0px";
	mdBut.onclick = function() { appendBlock("md", block); }
	
	let jsBut = make('button', "HTML/JS");
	jsBut.classList.add("center");
	jsBut.style.marginRight = "0px";
	jsBut.onclick = function() { appendBlock("js", block) };
	
	let imageBut = make('button', "Image");
	imageBut.classList.add("center");
	imageBut.onclick = function() { appendBlock("image", block) };
	
	let delBut = make('button', "✕");
	delBut.classList.add("right");
	delBut.onclick = function() {
		if (D('postContent').children.length > 1) D('postContent').removeChild(block);
		else alert("At least one element required. Add a replacement first.");
	};

	let buttonPanel = make('div');
	buttonPanel.style = "display:flex; justify-content:right";
	buttonPanel.appendChild(textBut);
	buttonPanel.appendChild(mdBut);
	buttonPanel.appendChild(jsBut);
	buttonPanel.appendChild(imageBut);
	buttonPanel.appendChild(delBut);
	
	let buttonParent = make('div');
	buttonParent.style = "margin-top:10px; margin-bottom:20px; display:flex; justify-content:space-between";
	buttonParent.appendChild(sponsBut);
	buttonParent.appendChild(buttonPanel);
	
	block.appendChild(buttonParent);
	if (parent && parent.nextElementSibling) D('postContent').insertBefore(block, parent.nextElementSibling);
	else D('postContent').appendChild(block);	
	
	for (let i = 0; i < buttonPanel.children.length; i++) {
		buttonPanel.children[i].tabIndex = -1;
	}
	textbox.focus();
	return block;
}

function cancelPost() {
	editPostid = "";
	D('editid').style.display = "none";
	D('creationEdit').textContent = " - ";
	D('creationEdit').title = "";
	D('modificationEdit').textContent = "";
	D('modificationEdit').title = "";	
	
	clearDOM(D('postContent'));	
	appendBlock();	
	
	D('postTitle').value = "";	
	D('set-prev').value = "";
	D('set-next').value = "";
	
	clearDOM(D('editTags'));
	D('set-tag').value = "";
	
	D('submitButton').textContent = "Publish";
	D('clearButton').textContent = "Clear";
	loadPanel(topPage);
}

function makeMetaLabel(userid, createdts, modifiedts) {	
	let postAuthor = make('a', funName(userid));
	postAuthor.title = userid;
	postAuthor.style.cursor = "pointer";
	postAuthor.style.fontWeight = "600";
	postAuthor.style.color = funColor(userid);
	postAuthor.onclick = function() {
		event.stopPropagation();
		queryBrowse(userid);
	};	
	queueDOMdisplayName(userid, postAuthor);
	
	let postDate = make('span', " • " + timeSince(createdts));	
	postDate.title = createdts;
		
	let postMeta = make('div');
	postMeta.style = "font-size:0.85em; overflow:hidden; text-overflow:ellipsis";
	postMeta.appendChild(postAuthor);
	postMeta.appendChild(postDate);	
	
	if (modifiedts && modifiedts != createdts) {
		let postModified = make('span', " - " + timeSince(modifiedts));
		postModified.title = modifiedts;
		postMeta.appendChild(postModified);
	}
	
	return postMeta;
}

function addComment(commentData) {
	let theComment = make('li', commentData.content);
	theComment.id = commentData.commentid;
	theComment.style = "margin-bottom:10px; font-size:0.9em";
	let theLabel = makeMetaLabel(commentData.commentid.split("-")[0], parseInt(commentData.commentid.split("-")[1]), commentData.modifiedts);

	// reply editor
	let editPanel = make('textarea');
	
	if (XNO.address == commentData.commentid.split("-")[0]) {	
		// let editBut = make('button', "Edit");
		let editBut = make('a', " • Edit");	
		editBut.style.cursor = "pointer";
		
		editPanel.placeholder = "Reply...";
		editPanel.style = "margin-bottom:10px; margin-top:10px; width:100%; display:none";		
		editPanel.oninput = function() {
			if (editPanel.value) editBut.textContent = " • Send Edit";
			else editBut.textContent = " • Cancel";
		};
		editPanel.onkeyup = function() {
			if (event.keyCode == 27) {
				editPanel.value = "";
				editPanel.style.display = "none";
				editBut.textContent = " • Edit";
				event.stopPropagation();
			}
		}
		
		// editBut.style = "padding:2px 8px; margin:2px; margin-left:10px;";				
		editBut.onclick = function() {
			if (editPanel.style.display) {
				editPanel.style.display = "";
				editPanel.value = D(commentData.commentid).textContent;
				this.textContent = " • Cancel";
			} else {
				editPanel.style.display = "none";
				if (editPanel.value && editPanel.value != D(commentData.commentid).textContent)
					ws.emit('updateComment', {content:editPanel.value, postid: commentData.postid, parentid: commentData.parentid, commentid: commentData.commentid });
				this.textContent = " • Edit";
			}
		};
		theLabel.appendChild(editBut);
	}	
		
	if (D(commentData.commentid)) D(commentData.commentid).textContent = commentData.content;
	else if (commentData.parentid) {
		D(commentData.parentid + "-ul").appendChild(theLabel);	
		if (XNO.address == commentData.commentid.split("-")[0])	D(commentData.parentid + "-ul").appendChild(editPanel);	
		D(commentData.parentid + "-ul").appendChild(theComment);
	} else {
		D('readComments').appendChild(theLabel);
		if (XNO.address == commentData.commentid.split("-")[0])	D('readComments').appendChild(editPanel);	
		D('readComments').appendChild(theComment);
		
		// future replies
		let ulcomment = make('ul');
		ulcomment.style = "margin-left:20px";
		ulcomment.id = commentData.commentid + "-ul";
		D('readComments').appendChild(ulcomment);
		
		// reply editor
		let repPanel = make('textarea');
		let repBut = make('button', "Reply");
		repPanel.style = "display:none; margin-left:20px; margin-bottom:10px; margin-top:20px; width:calc(100% - 20px);";
		repPanel.placeholder = "Reply...";
		repPanel.oninput = function() {
			if (repPanel.value) repBut.textContent = "Reply";
			else repBut.textContent = "Cancel";
		};
		repPanel.onkeyup = function() {
			if (event.keyCode == 27) {
				repPanel.value = "";
				repPanel.style.display = "none";
				repBut.textContent = "Reply";
				event.stopPropagation();
			}
		}		
		D('readComments').appendChild(repPanel);				
		
		// reply button
		repBut.style = "font-size:0.85em;";
		repBut.title = commentData.commentid;
		if (!XNO.address) repBut.disabled = true;
		
		repBut.onclick = function() {
			if (repPanel.style.display == "none") {
				repPanel.style.display = "block";
				this.textContent = "Cancel";
				repPanel.focus();
			} else {
				repPanel.style.display = "none";
				this.textContent = "Reply";	
				console.log({content:repPanel.value, postid: commentData.postid, parentid: commentData.commentid });
				if (repPanel.value) ws.emit('updateComment', {content:repPanel.value, postid: commentData.postid, parentid: commentData.commentid });
				repPanel.value = "";
			}
		};
		
		let repButHolder = make('div');
		repButHolder.style = "display:flex; justify-content:right; margin-right:10px";
		repButHolder.appendChild(repBut);
		D('readComments').appendChild(repButHolder);
	}
}


// Sidebar UI interaction handlers ///////////////////////////////////////////////////////////////////////

function testFunction() {
	if (ws && ws.readyState == 1) ws.emit('queryPostsRecent');
}

var clipboardText;

function generateSeed() {
	let newSeed = XNO.generateSeed();
	inputEvent(D("seed"), newSeed);
	if (D("seed").value) {
		navigator.clipboard.writeText(newSeed);
		clipboardText = newSeed;
		showMsg("New PIN copied to clipboard. Save it safely, elsewhere!");
	}
}

function importSeed() {
	let seed = D("seed").value;
	let index = 0;
	if (!XNO.checkSeed(seed)) { if (XNO.checkAddress(seed)) showMsg("Enter a PIN, not an address."); }
	else if (seed == XNO.seed) return false;
	else if (index.length > 0 && (!/^[0-9]+$/.test(index) || index < 0 || index > Math.pow(2, 32) - 1)) showMsg("Invalid account index.");
	else if (XNO.address && !confirm('Log out of the current account? (Have you have saved your account PIN elsewhere?!)')) {
		D("seed").value = "";
		return false;
	} else {
		clearSeed();		
		XNO.unpackSeed(seed, parseInt(index));
		
		D('displayName').textContent = funName(XNO.address, true);
		D('address').textContent = XNO.address;	
		
		D("current").disabled = false;
		D("clear").disabled = false;
		D("submitButton").disabled = false;
		//D("profilePanel").style.display = "";
		D("setDisplayBut").disabled = false;
		D("grayout").style.opacity = "";
		D("libraryPlaceholder").textContent = "Read something!";
		
		D("subPanel").style.display = "flex";
		
		clearDOM(D('subscriptions'));
		if (XNO.address) makeSubLi(XNO.address);
		D('subscribe').disabled = false;
		
		localStorage.setItem("localSeed", XNO.seed);
		closeSubAccordion(D('editPanel'));
		if (ws && ws.readyState == 1) {
			let ts = Date.now();
			console.log({userid: XNO.address, ts, signature:XNO.sign(ts, XNO.address)});
			ws.emit('authenticateUser', {userid: XNO.address, ts, signature:XNO.sign(ts, XNO.address)});
		}
	}
}

function queueDOMdisplayName(userid, elt) {
	if (!DOMdisplayNames[userid]) DOMdisplayNames[userid] = [elt];
	else DOMdisplayNames[userid].push(elt);
}

function requestNames() {
	let userids = [];	
	for (let name in DOMdisplayNames) {
		userids.push(name);
	}
	if (ws && ws.readyState == 1) ws.emit('queryUsers', {userids});
}

function queryPost(postid) {
	if (!postid) postid = readPostid;
	let split = postid.split("-");
	let userid = split[0];
	let createdts = parseInt(split[1]);		
	ws.emit('queryPost', { userid: userid, createdts: createdts });	
}

function makeSubLi(userid, lastaccessedts, lastpublishedts) {
	let tag = (userid.substring(0, 5) != "nano_");
	let name = userid;
	if (!tag) name = funName(userid);
	
	let subli = make("li");
	subli.id = userid;
	subli.onclick = function() {
		loadPanel('browse');
		if (ws && ws.readyState == 1) {
			D('loadingMsg').style.display = "";
			if (userid == XNO.address) D('subscribe').style.display = "none";
			else D('subscribe').style.display = "";
			if (!tag) queryBrowse(userid);
			else queryBrowse(null, userid);
			D('info').title = userid;
			if (!tag) ws.emit("queryPostsFromUser", {userid});
			else ws.emit("queryTag", {tag:userid});
		}
	};
	subli.style = "cursor:pointer; width:100%; padding:3px; position:relative";
	
	let actions = make('div');
	actions.style = "position:absolute; top:0px; right:0px; display:none; opacity:0.8";
	subli.appendChild(actions);	
	subli.onmouseenter = function() { actions.style.display = ""; }
	subli.onmouseleave = function() { actions.style.display = "none"; }
	
	if (userid != XNO.address) {
		let unsubBut = make("button", "✕");
		unsubBut.style.marginRight = "5px";
		unsubBut.onclick = function() {
			event.stopPropagation();
			subli.parentNode.removeChild(subli);
			if (ws && ws.readyState == 1) ws.emit('unsubscribe', {userid});
		};	
		actions.appendChild(unsubBut);
	}
	
	let nameSpan = make('span', name);
	nameSpan.style.fontWeight = "600";
	subli.appendChild(nameSpan);
	
	if (!tag) {
		nameSpan.style.color = funColor(userid);
		queueDOMdisplayName(userid, nameSpan);
	}
	
	if (lastpublishedts) {
		let publishSpan = make('span', timeSince(lastpublishedts));
		publishSpan.style = "margin-left:10px; font-size:0.85em";
		subli.appendChild(publishSpan);
		
		if (lastaccessedts) {
			//let accessSpan = make('span', timeSince(lastaccessedts));
			//subli.appendChild(accessSpan);
			if (lastaccessedts < lastpublishedts) {
				subli.style.fontWeight = "bold";
				console.log("UNREAD");
			} else console.log("read");
		}
	}
	
	D('subscriptions').appendChild(subli);
}

function makeLibLi(postid, accessts) {
	let libli = make('li');
	libli.id = postid;
	libli.style = "white-space:nowrap";
	if (!accessts) libli.style.fontWeight = "bold";	
	if (postid == readPostid) activeBar(libli);
	libli.appendChild(fullLabel(postid, true));	
	if (D('library').children[0]) D('library').insertBefore(libli, D('library').children[0]);
	else {
		D('library').appendChild(libli);
		D('libraryPlaceholder').style.display = "none";
	}
}

function addToLib(postid, addOnly) {
	let metaData = postCache[postid];
	let ts = Date.now();
	if (XNO.address && ws && ws.readyState == 1) {
		let libdata = { posts: [{ userid:metaData.userid, createdts:metaData.createdts, pushedts:ts }] };
		if (!addOnly) libdata.posts[0].lastaccessedts = ts;
		console.log("Emitting signal to add to DB library.");
		console.log(libdata);
		ws.emit('updateLibrary', libdata);
	}
	let accessedts;
	if (!addOnly) accessedts = ts;
	makeLibLi(postid, accessedts);
}

function showCurrent() {
	if (XNO.seed) {
		D(`seed`).value = XNO.seed;
		flash(D(`seed`));
	} else console.log("No seed loaded.");
}

function clearSeed() {
	// clearing actions that are needed even if switching accounts
	clearDOM(D('subscriptions'));
	clearDOM(D('library'));
	D('libraryPlaceholder').style.display = "";	
	if (D('creationEdit').title) cancelPost();
}

function clickClearSeed() {
	XNO.privateKey = "";
	XNO.publicKey = "";
	XNO.address = "";
	XNO.seed = "";
	XNO.encryptKey = "";
	
	clearSeed();	
	inputEvent(D('seed'), "");
	D('address').textContent = " - ";
	
	D("current").disabled = true;	
	D("clear").disabled = true;
	D("submitButton").disabled = true;
	D("comment").disabled = true;
	D('subscribe').disabled = true;
	closeSubAccordion(D('editPanel'));
	//D("profilePanel").style.display = "none";
	D("setDisplayBut").disabled = true;
	D("libraryPlaceholder").textContent = "Read something! (Log in to persist this list.)";
	
	D("grayout").style.opacity = "0.3";
	D("subPanel").style.display = "none";
	D('displayName').textContent = "Guest";	
	localStorage.removeItem("localSeed");
}

function toggleVisibility() {
	let x = D("seed");
	if (x.type === "password") {
		x.type = "text";
		D("show").classList.add('active');
	} else {
		x.type = "password";		
		D("show").classList.remove('active');
	}
}
	
function setData(type) {
	if (type == 'name') {
		if (ws && ws.readyState == 1) ws.emit('updateDisplayName', { displayname: D('set-name').value} );
	} else console.error("Need code to set " + type);
}

// Global event listeners ///////////////////////////////////////////////////////////////////////

window.addEventListener('popstate', loadURL);

function loadURL() {
	let postid = new URLSearchParams(window.location.search).get('postid');
	let tag = new URLSearchParams(window.location.search).get('tag');
	let userid = new URLSearchParams(window.location.search).get('userid');
	if (postid) {
		if (postCache[postid]) fillPost(postid);
		if (!postCache[postid] || !postCache[postid].comments) queryPost(postid);
		loadPanel('read');
	} else if (tag) queryBrowse(null, tag);
	else if (userid) queryBrowse(userid);
	else queryBrowse();
	
	if (ws && ws.readyState == 3) {
		ws = new WebSocket(serverURL);
		setupWebsocket();
	}
}

window.addEventListener('message', function (e) {
	if (e.data.height && e.data.height > 0) {
		let h = e.data.height;
		if (h > 4096) h = 4096;		
		Array.from(document.getElementsByTagName('iframe')).filter(iframe => {
			return iframe.contentWindow === event.source;
		})[0].style.height = h + "px";
	}
});

window.addEventListener('copy', function(e) { 
	if (document.activeElement.tagName.toLowerCase() == 'input') clipboardText = document.activeElement.value.substring(document.activeElement.selectionStart, document.activeElement.selectionEnd);
	else {
		if (document.getSelection().toString()) {
			clipboardText = document.getSelection().toString();	
			navigator.clipboard.writeText(clipboardText);
		}
	}
});

window.addEventListener('keydown', function(evt) {
	if (evt.altKey) {
		if (evt.keyCode == 49) loadPanel('browse');
		if (evt.keyCode == 50) loadPanel('read');
		if (evt.keyCode == 51) loadPanel('post');		
		if (evt.keyCode == 81) {
			//loadPanel('post');
			if (active('postButton') && D('postContent').style.display == "none") showEditor();
		}
		if (evt.keyCode == 87) {
			//loadPanel('post');
			if (active('postButton') && D('postPreview').style.display == "none") showPreview();			
		}
	}
		
	if (document.activeElement.tagName.toLowerCase() != 'input' && document.activeElement.tagName.toLowerCase() != 'textarea') {
		if (evt.keyCode == 8) {			
			let postid = new URLSearchParams(window.location.search).get('postid');
			let tag = new URLSearchParams(window.location.search).get('tag');
			let userid = new URLSearchParams(window.location.search).get('userid');
			
			if (postid) {
				if (D('read').style.display == "none") {
					evt.preventDefault();
					loadPanel('read');
				}
			} else if (D('browse').style.display == "none") {
				evt.preventDefault();
				loadPanel('browse');
			}	
		} else if (evt.keyCode == 27) {
			evt.preventDefault();
			loadPanel('browse');	
		}
	}
});

// UI helper library ///////////////////////////////////////////////////////////////////////

function funName(userid, pencil) {
	let pencilLiteral = "";
	// if (pencil) pencilLiteral = "✏️ ";
	if (cacheDisplayNames[userid]) return pencilLiteral + cacheDisplayNames[userid];
	return pencilLiteral + adj[parseInt(XNO.pubFromAddr(userid).substring(0, 10), 16) % adj.length] + " " 
											+ animals[parseInt(XNO.pubFromAddr(userid).substring(0, 10), 16) % animals.length];
}

function funColor(userid) {
	return "hsl(" + parseInt(XNO.pubFromAddr(userid).substring(0, 10), 16) % 360 + ", 100%, 27%)";
}

function D(string) { 
if (!string) console.error("Empty dom string");
return document.getElementById(string); 
}

function toggleSubAccordion(but) {
	let obj = but.parentNode.lastElementChild;
	if (obj.style.maxHeight == "0px") openSubAccordion(but.parentNode);
	else closeSubAccordion(obj); 
}

function closeSubAccordion(obj) {
	if (obj.style.maxHeight != "0px") showAccordion(obj);
	setTimeout(function() { 
		obj.style.maxHeight = "0px";
		obj.style.marginTop = "0px";
	}, 1);
}

function openSubAccordion(but) {
	let obj = but.lastElementChild;	
	if (obj.style.maxHeight == "0px") {
		showAccordion(obj);	
		setTimeout(function() { if (obj.style.maxHeight != "0px") obj.style.maxHeight = ""; }, 100);
	}
}

function showAccordion(obj) { obj.style.maxHeight = obj.scrollHeight + "px"; }

function flash(elt, str) {
	if (elt) {
		if (str != undefined) elt.textContent = str;
		elt.style.backgroundColor = 'aliceblue';	
		setTimeout(function() {	elt.style.backgroundColor = "";}, 500);
	} else console.log("Element disappeared before display.");
}

function inputEvent(obj, value) {
	obj.value = value;
	obj.dispatchEvent(new Event('input', {bubbles:true}));
	if (value) flash(obj);
}

function closeCopy(obj) {
	if (obj.value.length > 0) inputEvent(obj, "");
	else if (navigator.clipboard.readText) {
		navigator.clipboard.readText()
			.then(function(text) { inputEvent(obj, text); })
			.catch(function() { if (clipboardText) inputEvent(obj, clipboardText); });
	}
	else if (clipboardText) inputEvent(obj, clipboardText);
}

function clickCopy(elt, str) {
	if (str.length > 1) {
		/* Copy the text inside the text field */
		navigator.clipboard.writeText(str);
		clipboardText = str;
		showMsg("Copied to clipboard.");
	}
	flash(elt);
}

var msgTimer;
function showMsg(str, bold, hold) {
	let e = new Date();
	D('msg').style.display = "";
	D('msg').style.transition = "";
	if (msgTimer) clearTimeout(msgTimer);
	D('msg').style.filter = "opacity(0.9)";
	// flash(D('msg'), e.toLocaleTimeString() + ": " + str);
	flash(D('msg'), str);
	if (bold) D('msg').style.backgroundColor = "#F00";
	if (!hold) msgTimer = setTimeout(function() {
		D('msg').style.transition = "filter 2s linear 0s";
		D('msg').style.filter = "opacity(0)";
	}, 5000);
}

function unixToDate(time) {
	let str = new Date(time);
	if (str.getYear() == (new Date(Date.now())).getYear()) return str.toLocaleDateString().slice(0, -5); 
	else return str.toLocaleDateString();	
}

function clearDOM(myNode) {	while (myNode.firstChild) { myNode.removeChild(myNode.lastChild); } }

function make(string, text) { 
	let myObj = document.createElement(string);
	if (text) myObj.textContent = text;
	return myObj;
}

function toggle(div) {
	if (div.classList.contains('active')) div.classList.remove('active');
	else div.classList.add('active');
}

function parseMd(md){  
  //ul
  md = md.replace(/^\s*\n\*/gm, '<ul>\n*');
  md = md.replace(/^(\*.+)\s*\n([^\*])/gm, '$1\n</ul>\n\n$2');
  md = md.replace(/^\*(.+)/gm, '<li>$1</li>');
  
  //ol
  md = md.replace(/^\s*\n\d\./gm, '<ol>\n1.');
  md = md.replace(/^(\d\..+)\s*\n([^\d\.])/gm, '$1\n</ol>\n\n$2');
  md = md.replace(/^\d\.(.+)/gm, '<li>$1</li>');
  
  //blockquote
  md = md.replace(/^\>(.+)/gm, '<blockquote>$1</blockquote>');
  
  //h
  md = md.replace(/[\#]{6}(.+)/g, '<h6>$1</h6>');
  md = md.replace(/[\#]{5}(.+)/g, '<h5>$1</h5>');
  md = md.replace(/[\#]{4}(.+)/g, '<h4>$1</h4>');
  md = md.replace(/[\#]{3}(.+)/g, '<h3>$1</h3>');
  md = md.replace(/[\#]{2}(.+)/g, '<h2>$1</h2>');
  md = md.replace(/[\#]{1}(.+)/g, '<h1>$1</h1>');
  
  //alt h
  md = md.replace(/^(.+)\n\=+/gm, '<h1>$1</h1>');
  md = md.replace(/^(.+)\n\-+/gm, '<h2>$1</h2>');
  
  //images
  md = md.replace(/\!\[([^\]]+)\]\(([^\)]+)\)/g, '<img src="$2" alt="$1" />');
  
  //links
  md = md.replace(/[\[]{1}([^\]]+)[\]]{1}[\(]{1}([^\)\"]+)(\"(.+)\")?[\)]{1}/g, '<a href="$2" title="$4">$1</a>');
  
  //font styles
  md = md.replace(/[\*\_]{2}([^\*\_]+)[\*\_]{2}/g, '<b>$1</b>');
  md = md.replace(/[\*\_]{1}([^\*\_]+)[\*\_]{1}/g, '<i>$1</i>');
  md = md.replace(/[\~]{2}([^\~]+)[\~]{2}/g, '<del>$1</del>');
  
  //pre
  md = md.replace(/^\s*\n\`\`\`(([^\s]+))?/gm, '<pre class="$2">');
  md = md.replace(/^\`\`\`\s*\n/gm, '</pre>\n\n');
  
  //code
  md = md.replace(/[\`]{1}([^\`]+)[\`]{1}/g, '<code>$1</code>');
  
  //p
  md = md.replace(/^\s*(\n)?(.+)/gm, function(m){
    return  /\<(\/)?(h\d|ul|ol|li|blockquote|pre|img)/.test(m) ? m : '<p>'+m+'</p>';
  });
  
  //strip p from pre
  md = md.replace(/(\<pre.+\>)\s*\n\<p\>(.+)\<\/p\>/gm, '$1$2');
  
  return md;
  
}

function timeSince(date) {
	if (typeof date !== 'object') date = new Date(date);

	var seconds = Math.floor((new Date() - date) / 1000);
	var intervalType;

	var interval = Math.floor(seconds / 31536000);
	if (interval >= 1) intervalType = 'y';
	else {
		interval = Math.floor(seconds / 2592000);
		if (interval >= 1) intervalType = 'mo';
		else {
			interval = Math.floor(seconds / 86400);
			if (interval >= 1) intervalType = 'd';
			else {
				interval = Math.floor(seconds / 3600);
				if (interval >= 1) intervalType = "h";
				else {
					interval = Math.floor(seconds / 60);
					if (interval >= 1) intervalType = "m";
					else {
						interval = seconds;
						intervalType = "s";
					}
				}
			}
		}
	}

	//  if (interval > 1 || interval === 0) intervalType += 's';
	return interval + intervalType;
}

function addTabbing(elt) {
	elt.style.tabSize = "4";
    elt.onkeydown = function(evt) {
        let text = elt.value;
        let sel = elt.selectionStart;
		let selEnd = elt.selectionEnd;
        switch(evt.key){
            case "Escape":
                evt.preventDefault();
				evt.stopPropagation();
				if (elt.parentNode.nextElementSibling) elt.parentNode.nextElementSibling.focus();
				else elt.parentNode.focus();
				break;
            case "Enter":
                if (sel == selEnd) {
                    // find start of the current line
                    while (sel > 0 && text[sel-1] != '\n') sel--;

                    let lineStart = sel;
                    while (text[sel] == ' ' || text[sel]=='\t') sel++;

                    if (sel > lineStart) {
                        evt.preventDefault();
                        // Insert carriage return and indented text
                        document.execCommand('insertText', false, "\n" + text.substr(lineStart, sel-lineStart));

                        // Scroll caret visible
                        elt.blur();
                        elt.focus();
                    }
                }
				break;
            case "Tab":
                evt.preventDefault();
                // selection?
                if (sel == selEnd) { // These operations are undoable
                    if (!evt.shiftKey) document.execCommand('insertText', false, "\t");
                    else if (elt.selectionStart > 0 && text[elt.selectionStart-1]=='\t') 
                        document.execCommand('delete');
                } else { // Block indent/unindent trashes undo stack.
                    // Select whole lines
                    while (sel > 0 && text[sel-1] != '\n') sel--;
                    while (selEnd > 0 && text[selEnd-1]!='\n' && selEnd < text.length) selEnd++;

                    // Get selected text
                    let lines = text.substr(sel, selEnd - sel).split('\n');

                    // Insert tabs
                    for (var i=0; i<lines.length; i++) {
                        // Don't indent last line if cursor at start of line
                        if (i==lines.length-1 && lines[i].length==0) continue;

                        // Tab or Shift+Tab?
                        if (evt.shiftKey) {
                            if (lines[i].startsWith('\t')) lines[i] = lines[i].substr(1);
                            else if (lines[i].startsWith("    ")) lines[i] = lines[i].substr(4);
                        } else lines[i] = "\t" + lines[i];
                    }
                    let output = lines.join('\n');

                    // Update the text area
                    elt.value = text.substr(0, sel) + output + text.substr(selEnd);
                    elt.selectionStart = sel;
                    elt.selectionEnd = sel + output.length; 
                }
        }
    } 
}

function active(elt) {
	if (typeof elt === 'string' || elt instanceof String) elt = D(elt);
	return elt.classList.contains('active');
}

</script>

</body>
</html>
